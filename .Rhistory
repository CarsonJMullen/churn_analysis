predcol = heat.colors(9)[9:1] ## see help(heat.colors)
predbreaks = seq(min(Y),max(Y),length=nclr)
residbreaks = seq(min(res),max(res),length=nclr) # borders of resid color bins
residmap <- function(e){
return(plotclr[cut(drop(e), residbreaks)]) ## cut sorts into bins
}
predmap <- function(y){
return(predcol[cut(drop(y),predbreaks)]) ## cut sorts into bins
}
par(mfrow=c(1,2))
## preds
map('state', 'california')
mtext("fitted values (k=9)",cex=2)
points(test[,3:2], col=predmap(near$fitted), pch=19, cex=1)
map('state', 'california')
mtext("Residuals (k=9)",cex=2)
points(test[,3:2], col=residmap(res), pch=19, cex=1)
library(tree)
library(MASS)
data(Boston)
attach(Boston)
WA_Fn.UseC_.Telco.Customer.Churn <- read.csv("~/Downloads/WA_Fn-UseC_-Telco-Customer-Churn.csv")
View(WA_Fn.UseC_.Telco.Customer.Churn)
View(WA_Fn.UseC_.Telco.Customer.Churn)
View(WA_Fn.UseC_.Telco.Customer.Churn)
library(tidyverse)
library(dplyr)
library(caret)
df <- WA_Fn.UseC_.Telco.Customer.Churn
# Create a function to convert "Yes" to 1 and "No" to 0
convert_to_binary <- function(column){
ifelse(column == "Yes", as.numeric(1), as.numeric(0))
}
df$Partner <- convert_to_binary(df$Partner)
df$Dependents <- convert_to_binary(df$Dependents)
df$PhoneService <- convert_to_binary(df$PhoneService)
df$OnlineSecurity <- convert_to_binary(df$OnlineSecurity)
df$OnlineBackup <- convert_to_binary(df$OnlineBackup)
df$DeviceProtection <- convert_to_binary(df$DeviceProtection)
df$TechSupport <- convert_to_binary(df$TechSupport)
df$StreamingTV <- convert_to_binary(df$StreamingTV)
df$StreamingMovies <- convert_to_binary(df$StreamingMovies)
df$PaperlessBilling <- convert_to_binary(df$PaperlessBilling)
df$MultipleLines <- convert_to_binary(df$MultipleLines)
df$Churn <- convert_to_binary(df$Churn)
df$gender = ifelse(df$gender == "Female", 1, 0)
df$InternetService <- as.factor(df$InternetService)
df$Contract <- as.factor(df$Contract)
df$PaymentMethod <- as.factor(df$PaymentMethod)
add_dummys <- df[, c("InternetService", "Contract", "PaymentMethod")]
dummy_data <- dummyVars(~ ., data = add_dummys)
df_with_dummies <- data.frame(predict(dummy_data, newdata = add_dummys))
df_without_dummies <- df %>%
select(-any_of(names(add_dummys)))
full_df <- cbind(df_without_dummies, df_with_dummies)
View(full_df)
model1 <- glm(Churn ~ . - customerID, data = full_df, family = binomial)
summary(model1)
backward_model <- step(model1, direction = "backward")
null_model <- glm(Churn ~ 1, data = full_df, family = binomial)
final_model_forward <- step(null_model, scope = formula(~ .), direction = "forward")
final_model_forward <- step(null_model, scope = formula(~ .), direction = "forward")
final_model_forward <- step(null_model, direction = "forward")
final_model_forward <- step(null_model, direction = "forward")
forward_model <- step(null_model, scope = model1, direction = "forward")
summary(backward_model)
# Replace 'your_model' with the appropriate model function (e.g., glm, randomForest, etc.)
predictors <- full_df %>%
select(-c(Churn, customerID))
View(predictors)
predictors <- full_df %>%
select(-c(Churn, customerID))
response <- full_df$Churn
ctrl <- trainControl(method = "cv", number = 10)  # 10-fold cross-validation
model <- train(predictors, response, method = model1, trControl = ctrl)
library(tidyverse)
library(dplyr)
library(caret)
df <- WA_Fn.UseC_.Telco.Customer.Churn
# Create a function to convert "Yes" to 1 and "No" to 0
convert_to_binary <- function(column){
ifelse(column == "Yes", as.numeric(1), as.numeric(0))
}
df$Partner <- convert_to_binary(df$Partner)
df$Dependents <- convert_to_binary(df$Dependents)
df$PhoneService <- convert_to_binary(df$PhoneService)
df$OnlineSecurity <- convert_to_binary(df$OnlineSecurity)
df$OnlineBackup <- convert_to_binary(df$OnlineBackup)
df$DeviceProtection <- convert_to_binary(df$DeviceProtection)
df$TechSupport <- convert_to_binary(df$TechSupport)
df$StreamingTV <- convert_to_binary(df$StreamingTV)
df$StreamingMovies <- convert_to_binary(df$StreamingMovies)
df$PaperlessBilling <- convert_to_binary(df$PaperlessBilling)
df$MultipleLines <- convert_to_binary(df$MultipleLines)
df$Churn <- convert_to_binary(df$Churn)
df$gender = ifelse(df$gender == "Female", 1, 0)
df$InternetService <- as.factor(df$InternetService)
df$Contract <- as.factor(df$Contract)
df$PaymentMethod <- as.factor(df$PaymentMethod)
add_dummys <- df[, c("InternetService", "Contract", "PaymentMethod")]
dummy_data <- dummyVars(~ ., data = add_dummys)
df_with_dummies <- data.frame(predict(dummy_data, newdata = add_dummys))
df_without_dummies <- df %>%
select(-any_of(names(add_dummys)))
full_df <- cbind(df_without_dummies, df_with_dummies)
model1 <- glm(Churn ~ . - customerID, data = full_df, family = binomial)
backward_model <- step(model1, direction = "backward")
null_model <- glm(Churn ~ 1, data = full_df, family = binomial)
forward_model <- step(null_model, direction = "forward")
# Cross Validate
predictors <- full_df %>%
select(-c(Churn, customerID))
response <- full_df$Churn
ctrl <- trainControl(method = "cv", number = 10)  # 10-fold cross-validation
model <- train(predictors, response, method = model1, trControl = ctrl)
# Assuming you have a data frame 'full_df' with predictor variables (excluding Churn and customerID) and a response variable 'Churn'.
predictors <- full_df %>% select(-c(Churn, customerID))
response <- full_df$Churn
# Create the trainControl object for 10-fold cross-validation
ctrl <- trainControl(method = "cv", number = 10)  # 10-fold cross-validation
# Fit the logistic regression model using cross-validation
model <- train(predictors, response, method = "glm", trControl = ctrl)
# Access the cross-validation results
print(summary(model))
conf_matrix <- confusionMatrix(predict(model, predictors), response)
# Access the cross-validation results
print(summary(model))
conf_matrix <- confusionMatrix(predict(model, predictors), response)
View(df_without_dummies)
cor(df_without_dummies)
df_without_dummies %>%
select(-customerID)
df_without_dummies <- df_without_dummies %>%
select(-customerID)
cor(df_without_dummies)
conf_matrix <- confusionMatrix(predict(model, predictors), response)
conf_matrix <- confusionMatrix(predict(model1, predictors), response)
conf_matrix <- confusionMatrix(predict(model, predictors), response)
set.seed(123)  # For reproducibility
train_index <- createDataPartition(response, p = 0.75, list = FALSE)
train_data <- predictors[train_index, ]
test_data <- predictors[-train_index, ]
train_response <- response[train_index]
test_response <- response[-train_index]
# Fit the logistic regression model using cross-validation on the training data
model <- train(train_data, train_response, method = "glm", trControl = ctrl)
# Access the cross-validation results
print(summary(model))
# Evaluate the model on the testing data
conf_matrix <- confusionMatrix(predict(model, test_data), test_response)
cor(df_without_dummies)
model1 <- glm(Churn ~ . - customerID - MonthlyCharges, data = full_df, family = binomial)
backward_model <- step(model1, direction = "backward")
backward_model <- step(model1, direction = "backward")
predict(full_df, model = model1)
predict(model1, newdata = full_df)
predict(model1, newdata = full_df %>% select(-c(customerID, MonthlyCharges))
)
predict(model1, newdata = full_df %>% select(-c(customerID, MonthlyCharges)))
df <- WA_Fn.UseC_.Telco.Customer.Churn
# Create a function to convert "Yes" to 1 and "No" to 0
convert_to_binary <- function(column){
ifelse(column == "Yes", as.factor(1), as.factor(0))
}
df$Partner <- convert_to_binary(df$Partner)
df$Dependents <- convert_to_binary(df$Dependents)
df$PhoneService <- convert_to_binary(df$PhoneService)
df$OnlineSecurity <- convert_to_binary(df$OnlineSecurity)
df$OnlineBackup <- convert_to_binary(df$OnlineBackup)
df$DeviceProtection <- convert_to_binary(df$DeviceProtection)
df$TechSupport <- convert_to_binary(df$TechSupport)
df$StreamingTV <- convert_to_binary(df$StreamingTV)
df$StreamingMovies <- convert_to_binary(df$StreamingMovies)
df$PaperlessBilling <- convert_to_binary(df$PaperlessBilling)
df$MultipleLines <- convert_to_binary(df$MultipleLines)
df$Churn <- convert_to_binary(df$Churn)
df$gender = ifelse(df$gender == "Female", 1, 0)
df$InternetService <- as.factor(df$InternetService)
df$Contract <- as.factor(df$Contract)
df$PaymentMethod <- as.factor(df$PaymentMethod)
View(df)
test <- glm(Churn ~ . - customerID, data = df, family = binomial)
library(tidyverse)
library(dplyr)
library(caret)
df <- WA_Fn.UseC_.Telco.Customer.Churn
# Create a function to convert "Yes" to 1 and "No" to 0
convert_to_binary <- function(column){
ifelse(column == "Yes", as.numeric(1), as.numeric(0))
}
df$Partner <- convert_to_binary(df$Partner)
df$Dependents <- convert_to_binary(df$Dependents)
df$PhoneService <- convert_to_binary(df$PhoneService)
df$OnlineSecurity <- convert_to_binary(df$OnlineSecurity)
df$OnlineBackup <- convert_to_binary(df$OnlineBackup)
df$DeviceProtection <- convert_to_binary(df$DeviceProtection)
df$TechSupport <- convert_to_binary(df$TechSupport)
df$StreamingTV <- convert_to_binary(df$StreamingTV)
df$StreamingMovies <- convert_to_binary(df$StreamingMovies)
df$PaperlessBilling <- convert_to_binary(df$PaperlessBilling)
df$MultipleLines <- convert_to_binary(df$MultipleLines)
df$Churn <- convert_to_binary(df$Churn)
df$gender = ifelse(df$gender == "Female", 1, 0)
df$InternetService <- as.factor(df$InternetService)
df$Contract <- as.factor(df$Contract)
df$PaymentMethod <- as.factor(df$PaymentMethod)
test <- glm(Churn ~ . - customerID, data = df, family = binomial)
summary(test)
test <- glm(Churn ~ . - customerID - TotalCharges, data = df, family = binomial)
summary(test)
test <- glm(Churn ~ . - customerID - TotalCharges - Partner, data = df, family = binomial)
summary(test)
test <- glm(Churn ~ . - customerID - TotalCharges - Partner - gender, data = df, family = binomial)
summary(test)
test <- glm(Churn ~ . - customerID - TotalCharges - Partner - gender - PhoneService, data = df, family = binomial)
summary(test)
test <- glm(Churn ~ (. - customerID - TotalCharges - Partner - gender - PhoneService)^2, data = df, family = binomial)
summary(test)
test <- glm(Churn ~ (. - customerID)^2, data = df, family = binomial)
summary(test)
test <- glm(Churn ~ TotalCharges, data = df, family = binomial)
summary(test)
#Creates a model with all variables
full_model <- glm(Churn ~ . - customerID + tenure*StreamingMovies, data = train_df, family = binomial)
setwd("~/Documents/GitHub/churn_analysis")
library(tidyverse)
library(dplyr)
library(caret)
library(MASS)
# Read data, make sure you set your directory
df <- read.csv('WA_Fn-UseC_-Telco-Customer-Churn.csv')
df <- na.omit(df)
# Create a function to convert "Yes" to 1 and "No" to 0
convert_to_binary <- function(column){
ifelse(column == "Yes", as.numeric(1), as.numeric(0))
}
columns_to_convert <- c("Partner", "Dependents", "PhoneService", "OnlineSecurity", )
library(tidyverse)
library(dplyr)
library(caret)
library(MASS)
# Read data, make sure you set your directory
df <- read.csv('WA_Fn-UseC_-Telco-Customer-Churn.csv')
df <- na.omit(df)
# Create a function to convert "Yes" to 1 and "No" to 0
convert_to_binary <- function(column){
ifelse(column == "Yes", as.numeric(1), as.numeric(0))
}
columns_to_convert <- c("Partner", "Dependents", "PhoneService", "OnlineSecurity",
"OnlineBackup", "DeviceProtection", "TechSupport",
"StreamingTV", "StreamingMovies", "PaperlessBilling",
"MultipleLines", "Churn")
# Use lapply to apply the convert_to_binary function to each column in the list
df[columns_to_convert] <- lapply(df[columns_to_convert], convert_to_binary)
View(df)
set.seed(123)
trainIndex <- createDataPartition(telecomChurn$Churn, p = 0.7, list = FALSE)
set.seed(123)
trainIndex <- createDataPartition(df, p = 0.7, list = FALSE)
set.seed(123)
trainIndex <- createDataPartition(df$Churn, p = 0.7, list = FALSE)
train_df <- telecomChurn[trainIndex, ]
set.seed(123)
trainIndex <- createDataPartition(df$Churn, p = 0.7, list = FALSE)
train_df <- df[trainIndex, ]
test_df <- df[-trainIndex, ]
View(train_df)
#Creates a model with all variables
full_model <- glm(Churn ~ . - customerID + tenure*StreamingMovies, data = train_df, family = binomial)
#Creates a model with all variables & interactions b/t all variables
full_interaction_model <- glm(Churn ~ (. - customerID)^2, data = train_df, family = binomial)
#Backward Selection
backward_model <- step(full_model, direction = "backward")
#Forward Selection
null_model <- glm(Churn ~ 1, data = df, family = binomial)
forward_model <- stepAIC(null_model, direction = "forward", scope = formula(full_model), trace = FALSE)
#Stepwise Selection
stepwise_model <- step(forward_model, scope=formula(full_model), direction="both")
summary(backward_model)
summary(forward_model)
summary(stepwise_model)
summary(forward_model)
predict(backward_model,newdata=test_df,type='response')
round(0.5)
round(0.51)
round(0.50)
round(0.501)
backward_predictions %>% round
backward_predictions <- predict(backward_model,newdata=test_df,type='response')
backward_predictions %>% round
sum(backward_predictions == test_df$Churn)
sum(backward_predictions == test_df$Churn)
backward_predictions
sum(backward_predictions %>% round == test_df$Churn)
sum(backward_predictions %>% round == test_df$Churn)/length(test_df)
# Load required libraries
library(randomForest)
setwd("~/Documents/GitHub/churn_analysis")
# Read data from CSV file
df <- read.csv('WA_Fn-UseC_-Telco-Customer-Churn.csv')
# Load required libraries
library(randomForest)
# Load required libraries
library(randomForest)
# Read data from CSV file
df <- read.csv('WA_Fn-UseC_-Telco-Customer-Churn.csv')
data <- na.omit(data)
categorical_vars <- c("Churn", "PaymentMethod", "PaperlessBilling", "Contract", "StreamingMovies",
"StreamingTV", "TechSupport", "DeviceProtection", "OnlineBackup", "OnlineSecurity",
"InternetService", "MultipleLines", "PhoneService", "Dependents", "Partner", "gender")
for (var in categorical_vars) {
data[[var]] <- as.factor(data[[var]])
}
# Convert categorical variables to factors
categorical_vars <- c("Churn", "PaymentMethod", "PaperlessBilling", "Contract", "StreamingMovies",
"StreamingTV", "TechSupport", "DeviceProtection", "OnlineBackup", "OnlineSecurity",
"InternetService", "MultipleLines", "PhoneService", "Dependents", "Partner", "gender")
for (var in categorical_vars) {
data[[var]] <- as.factor(data[[var]])
}
convert_to_binary <- function(column){
ifelse(column == "Yes", as.factor(1), as.factor(0))
}
df[columns_to_convert] <- lapply(df[columns_to_convert], convert_to_binary)
set.seed(123)
train_indices <- sample(1:nrow(data), 0.7 * nrow(data))  # 70% for training
# Split the data into training and test sets
set.seed(123)
train_indices <- sample(1:nrow(data), 0.7 * nrow(data))  # 70% for training
set.seed(123)
trainIndex <- createDataPartition(df$Churn, p = 0.7, list = FALSE)
# Split the data into training and test sets
set.seed(123)
trainIndex <- createDataPartition(df$Churn, p = 0.7, list = FALSE)
View(df)
convert_to_binary <- function(column){
ifelse(column == "Yes", as.numeric(1), as.numeric(0))
}
df[columns_to_convert] <- lapply(df[columns_to_convert], convert_to_binary)
library(randomForest)
# Read data from CSV file
df <- read.csv('WA_Fn-UseC_-Telco-Customer-Churn.csv')
data <- na.omit(data)
# Convert categorical variables to factors
categorical_vars <- c("Churn", "PaymentMethod", "PaperlessBilling", "Contract", "StreamingMovies",
"StreamingTV", "TechSupport", "DeviceProtection", "OnlineBackup", "OnlineSecurity",
"InternetService", "MultipleLines", "PhoneService", "Dependents", "Partner", "gender")
convert_to_binary <- function(column){
ifelse(column == "Yes", as.numeric(1), as.numeric(0))
}
df[columns_to_convert] <- lapply(df[columns_to_convert], convert_to_binary)
library(randomForest)
# Read data from CSV file
df <- read.csv('WA_Fn-UseC_-Telco-Customer-Churn.csv')
data <- na.omit(data)
# Convert categorical variables to factors
categorical_vars <- c("Churn", "PaymentMethod", "PaperlessBilling", "Contract", "StreamingMovies",
"StreamingTV", "TechSupport", "DeviceProtection", "OnlineBackup", "OnlineSecurity",
"InternetService", "MultipleLines", "PhoneService", "Dependents", "Partner", "gender")
convert_to_binary <- function(column){
ifelse(column == "Yes", as.numeric(1), as.numeric(0))
}
df[categorical_vars] <- lapply(df[categorical_vars], convert_to_binary)
set.seed(123)
trainIndex <- createDataPartition(df$Churn, p = 0.7, list = FALSE)
train_df <- df[trainIndex, ]
test_df <- df[-trainIndex, ]
# Train the random forest model
rf_model <- randomForest(Churn ~ ., data = train_data, ntree = 100, mtry = 2)
# Train the random forest model
rf_model <- randomForest(Churn ~ ., data = train_df, ntree = 100, mtry = 2)
library(randomForest)
# Read data from CSV file
data <- read.csv('WA_Fn-UseC_-Telco-Customer-Churn.csv')
data <- na.omit(data)
library(randomForest)
# Read data from CSV file
data <- read.csv('WA_Fn-UseC_-Telco-Customer-Churn.csv')
data <- na.omit(data)
# Convert categorical variables to factors
categorical_vars <- c("Churn", "PaymentMethod", "PaperlessBilling", "Contract", "StreamingMovies",
"StreamingTV", "TechSupport", "DeviceProtection", "OnlineBackup", "OnlineSecurity",
"InternetService", "MultipleLines", "PhoneService", "Dependents", "Partner", "gender")
for (var in categorical_vars) {
data[[var]] <- as.factor(data[[var]])
}
# Split the data into training and test sets
set.seed(1)
train_indices <- sample(1:nrow(data), 0.7 * nrow(data))  # 70% for training
train_data <- data[train_indices, ]
test_data <- data[-train_indices, ]
# Train the random forest model
rf_model <- randomForest(Churn ~ ., data = train_data, ntree = 100, mtry = 2)
# Make predictions on the test data
predictions <- predict(rf_model, newdata = test_data)
# Evaluate model performance
accuracy <- sum(predictions == test_data$Churn) / nrow(test_data)
cat("Accuracy: ", accuracy, "\n")
# View variable importance
varImpPlot(rf_model)
# Load required libraries
library(randomForest)
# Read data from CSV file
data <- read.csv('WA_Fn-UseC_-Telco-Customer-Churn.csv')
data <- na.omit(data)
# Convert categorical variables to factors
categorical_vars <- c("Churn", "PaymentMethod", "PaperlessBilling", "Contract", "StreamingMovies",
"StreamingTV", "TechSupport", "DeviceProtection", "OnlineBackup", "OnlineSecurity",
"InternetService", "MultipleLines", "PhoneService", "Dependents", "Partner", "gender")
for (var in categorical_vars) {
data[[var]] <- as.factor(data[[var]])
}
# Split the data into training and test sets
set.seed(123)
train_indices <- sample(1:nrow(data), 0.7 * nrow(data))  # 70% for training
train_data <- data[train_indices, ]
test_data <- data[-train_indices, ]
# Train the random forest model
rf_model <- randomForest(Churn ~ ., data = train_data, ntree = 100, mtry = 2)
# Make predictions on the test data
predictions <- predict(rf_model, newdata = test_data)
# Evaluate model performance
accuracy <- sum(predictions == test_data$Churn) / nrow(test_data)
cat("Accuracy: ", accuracy, "\n")
# View variable importance
varImpPlot(rf_model)
# Load required libraries
library(randomForest)
# Read data from CSV file
data <- read.csv('WA_Fn-UseC_-Telco-Customer-Churn.csv')
data <- na.omit(data)
# Convert categorical variables to factors
categorical_vars <- c("Churn", "PaymentMethod", "PaperlessBilling", "Contract", "StreamingMovies",
"StreamingTV", "TechSupport", "DeviceProtection", "OnlineBackup", "OnlineSecurity",
"InternetService", "MultipleLines", "PhoneService", "Dependents", "Partner", "gender")
for (var in categorical_vars) {
data[[var]] <- as.factor(data[[var]])
}
# Split the data into training and test sets
set.seed(123)
train_indices <- sample(1:nrow(data), 0.7 * nrow(data))  # 70% for training
train_data <- data[train_indices, ]
test_data <- data[-train_indices, ]
# Train the random forest model
rf_model <- randomForest(Churn ~ .-TotalCharges, data = train_data, ntree = 100, mtry = 2)
# Make predictions on the test data
predictions <- predict(rf_model, newdata = test_data)
# Evaluate model performance
accuracy <- sum(predictions == test_data$Churn) / nrow(test_data)
cat("Accuracy: ", accuracy, "\n")
# View variable importance
varImpPlot(rf_model)
summary(backward_model)
library(tidyverse)
library(dplyr)
library(caret)
library(MASS)
# Read data, make sure you set your directory
df <- read.csv('WA_Fn-UseC_-Telco-Customer-Churn.csv')
df <- na.omit(df)
# Create a function to convert "Yes" to 1 and "No" to 0
convert_to_binary <- function(column){
ifelse(column == "Yes", as.numeric(1), as.numeric(0))
}
columns_to_convert <- c("Partner", "Dependents", "PhoneService", "OnlineSecurity",
"OnlineBackup", "DeviceProtection", "TechSupport",
"StreamingTV", "StreamingMovies", "PaperlessBilling",
"MultipleLines", "Churn")
# Use lapply to apply the convert_to_binary function to each column in the list
df[columns_to_convert] <- lapply(df[columns_to_convert], convert_to_binary)
df$gender = ifelse(df$gender == "Female", 1, 0)
df$Churn <- factor(df$Churn)
##### Split into Test/Train Split
set.seed(123)
trainIndex <- createDataPartition(df$Churn, p = 0.7, list = FALSE)
train_df <- df[trainIndex, ]
test_df <- df[-trainIndex, ]
##### Building Models
#Creates a model with all variables
full_model <- glm(Churn ~ . - customerID + tenure*StreamingMovies, data = train_df, family = binomial)
#Creates a model with all variables & interactions b/t all variables
full_interaction_model <- glm(Churn ~ (. - customerID)^2, data = train_df, family = binomial)
#Summaries
summary(full_model)
summary(full_interaction_model)
#Backward Selection
backward_model <- step(full_model, direction = "backward")
#Forward Selection
null_model <- glm(Churn ~ 1, data = df, family = binomial)
forward_model <- stepAIC(null_model, direction = "forward", scope = formula(full_model), trace = FALSE)
#Stepwise Selection
stepwise_model <- step(forward_model, scope=formula(full_model), direction="both")
summary(backward_model)
summary(forward_model)
summary(stepwise_model)
backward_predictions <- predict(backward_model,newdata=test_df,type='response')
backward_predictions %>% round
sum(backward_predictions %>% round == test_df$Churn)/length(test_df)
summary(backward_model)
#Creates a model with all variables
full_model <- glm(Churn ~ . - customerID - MonthlyCharges+ tenure*StreamingMovies, data = train_df, family = binomial)
#Backward Selection
backward_model <- step(full_model, direction = "backward")
summary(backward_model)
#Creates a model with all variables
full_model <- glm(Churn ~ . - customerID - TotalCharges+ tenure*StreamingMovies, data = train_df, family = binomial)
#Backward Selection
backward_model <- step(full_model, direction = "backward")
summary(backward_model)
e^-0.023896
e
math.e
